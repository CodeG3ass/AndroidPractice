# Жизненный цикл сервиса
## Цель работы
Познакомиться с жизненным циклом связанного и свободного сервиса в ОС Android, увидеть на практике порядок вызова методов жизненного цикла.  
## Задания для выполнения  
1.	Создайте в приложении сервис, переопределив все основные методы жизненного цикла. Каждый метод должен выводить в консоль свое название при вызове.  

![image](https://user-images.githubusercontent.com/92590831/154649284-697e95a4-afef-403a-bf4d-62aafa5481df.png)

![image](https://user-images.githubusercontent.com/92590831/154649310-f4a6ba60-f1c8-4bb8-8e00-9be6342b4d9b.png)

2.	Не забудьте вызов методов суперкласса и объявление сервиса в манифесте приложения.  

![image](https://user-images.githubusercontent.com/92590831/154649254-92b76e59-ae36-41ed-8f6b-a0defdb78d80.png)


4.	В основной активности создайте две конопки. При нажатии на первую интент, вызывающий созданный сервис (явный интент) рассылается методом startService(), при нажатии второй - методом bindService(). 

![image](https://user-images.githubusercontent.com/92590831/154649169-1f214459-3015-4aba-83da-ff70e74221ec.png)
 
6.	Запустите приложение и понаблюдайте за жизненным циклом сервиса.  


## Контрольные вопросы  
### 1.	Когда происходит создание и удаление связанного сервиса?  
Связанная служба — это реализация Serviceкласса, которая позволяет другим приложениям связываться с ней и взаимодействовать с ней. Чтобы обеспечить привязку для службы, необходимо реализовать onBind()метод обратного вызова. Этот метод возвращает IBinderобъект, определяющий программный интерфейс, который клиенты могут использовать для взаимодействия со службой.

Привязка к запущенному сервису
Как обсуждалось в документе « Службы », вы можете создать службу, которая будет запущена и привязана. То есть вы можете запустить службу, вызвав startService(), что позволит службе работать неограниченное время, а также вы можете разрешить привязку клиента к службе, вызвав bindService().

Если вы разрешаете запуск и привязку службы, то при запуске службы система не уничтожает службу при отвязке всех клиентов. Вместо этого вы должны явно остановить службу, вызвав stopSelf()или stopService().

Хотя обычно вы реализуете или onBind() или onStartCommand() , иногда необходимо реализовать и то, и другое. Например, музыкальный проигрыватель может счесть полезным разрешить своему сервису работать неограниченное время, а также обеспечить привязку. Таким образом, действие может запустить службу для воспроизведения музыки, и музыка будет продолжать воспроизводиться, даже если пользователь выйдет из приложения. Затем, когда пользователь возвращается в приложение, действие может привязаться к службе, чтобы восстановить контроль над воспроизведением.

### 2.	Какие методы жизненного цикла вызываются у сервиса и в какой последовательности?  

onCreate() – вызывается при первом создании Activity
onStart() – вызывается перед тем, как Activity будет видно пользователю
onResume() – вызывается перед тем как будет доступно для активности пользователя (взаимодействие)

onPause() – вызывается перед тем, как будет показано другое Activity
onStop() – вызывается когда Activity становится не видно пользователю
onDestroy() – вызывается перед тем, как Activity будет уничтожено

Т.е. эти методы НЕ вызывают смену состояния. Наоборот, смена состояния Activity является триггером, который вызывает эти методы. Тем самым нас уведомляют о смене, и мы можем реагировать соответственно. Посмотрим на практике, когда и в каком порядке вызываются эти методы.

У методов onCreate(), onStart(), onResume() вызов суперкласса должен происходить до вызова вашего кода. В методах onPause(), onStop(), onDestroy() суперкласс следует вызывать после вашего кода (не обращайте внимания на мои примеры).

После onCreate() - onStart()

После onRestart() - onStart()

После onStart() - onResume() или onStop()

После onResume() - onPause()

После onPause() - onResume() или onStop()

После onStop() - onRestart() или onDestroy()

После onDestroy() - ничего
### 3.	Как соотносится ЖЦ активности и сервиса?  

Жизненный цикл сервиса намного проще жизненного цикла активности. Однако для разработчика понимание того, как именно сервис создается, запускается и завершает свою работу, может оказаться даже более важным, т. к. сервис работает в фоновом режиме и пользователь может и не осознавать, что в некоторых случаях он имеет дело с работой сервисов.

Android принудительно останавливает работу сервисов только, когда ресурсов системы не хватает для активности, которая работает в данный момент на переднем плане. Приоритет работающих сервисов всегда выше, чем у приостановленных или полностью невидимых активностей, а если сервис привязан к выполняющейся активности, то его приоритет еще выше. С другой стороны, со временем приоритет самостоятельно работающего сервиса понижается и его шансы быть принудительно остановленным системой в случае нехватки ресурсов повышаются. В связи с этим имеет смысл проектировать сервис таким образом, чтобы через некоторое время он требовал у системы перезапуска. В случае если система все таки экстренно завершила работу сервиса, она перезапустит его как только освободятся ресурсы.

