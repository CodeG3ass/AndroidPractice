Контрольные вопросы
1.	Какие существуют соглашения в порядке наименования действий?
Некоторые стандартные действия определены в классе Intent как константы ACTION_string, где string — название действия. Указывать такие действие нужно так: android.Intent.ACTION_string. Например, sndroid.Intent.ACTION_VIEW. Для действий, которые определяет разработчик, лучше всего использовать имя пакета приложения в качестве префикса для обеспечения уникальности. Например, com.example.project.CUSTOM_ACTION, где CUSTOM_ACTION — имя действия.
2.	Как передать информацию в активность используя неявный вызов?
Предать информацию в активность используя неявный вызов можно, указав ее вторым аргументом. Например, чтобы создать неявный интент с действием открытия ссылки в браузере, нужно указать адрес (объект Uri) вторым аргументом: 
Intent openLinkIntent = new Intent(Intent.ACTION_VIEW, address);
3.	Какие еще параметры можно задавать при создании неявного интента?
Можно указать пары ключ-значения для дополнительной информации так же, как это делается при вызове явного интента с помощью ряда методов Intent.put...(). Например, чтобы сохранить фотографию, сделанную пользователем из нашего приложения, в файл, нужно указать ключ MediaStore.EXTRA_OUTPUT и Uri, сооответсвующее файлу:
Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
4.	Зачем нужна категория в интент-фильтрах? Какие существуют категории?
Категории нужны, чтобы указать, при каких обстоятельствах действие должно обслуживаться. Можно задать собственные категории или же брать стандартные значения, предоставляемые системой:
•	ALTERNATIVE — действие должно быть доступно в качестве альтернативного тому, которое выполняется по умолчанию для элемента этого типа данных.
•	BROWSABLE — говорит о том, что действие доступно из браузера.
•	DEFAULT — категория, позволяющая сделать компонент обработчиком по умолчанию для действия, выполняемого с указанным типом.
•	GADGET — наличие этой категории указывает на то, что данная активность может запускаться внутри другой активности.
•	LAUNCHER — используя эту категорию, мы помещаем Activity в окно для запуска приложений.
•	и др.
5.	Зачем нужен элемент  <requestFocus>?
Элемент <requestFocus> позволяет установить фокус на нужном компоненте. Предположим, что у нас имеется три текстовых поля, и нужно, чтобы фокус был на втором поле. В этом случае достаточно добавить тег <requestFocus> внутри второго элемента EditText.
6.	Зачем нужны аргументы requestCode и resultCode в обратном интенте?
requestCode - это неотрицательное целое число, которое запоминается (обычно записывается в поле класса активности, вызывающей другое действие, как константа) и передается в функцию StartActivityForResult() вторым аргументом. Это число позволяет при завершении одной из активности в методе onActivityResult() различить по этому числу, какая именно Activity была завершена. А resultCode позволяет определить успешно
